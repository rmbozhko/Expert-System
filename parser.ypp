%verbose
%{
    #include "src/Tree.hpp"
    #include "src/Operation.hpp"
    #include "src/LogicOperations.hpp"
    #include "src/Fact.hpp"
    #include <cstring>
    #include <cstdio>
    #include <iostream>
    #include <vector>
    #include <map>
    #include "src/Node.hpp"
    int yylex();
    extern "C" int yyparse ();
    extern "C" FILE* yyin;
    extern unsigned    linenum;
	void        yyerror(std::vector<Tree*>& treeStrg, std::map<std::string, Fact*>& factsStrg, std::vector<std::string>& factsOutput, const char* s);
%}


%code requires {
    #include "src/Node.hpp"
    #include "src/Exceptions.hpp"
    #include "src/Tree.hpp"
    #include "src/Operation.hpp"
    #include "src/Fact.hpp"
    #include <map>
}

%parse-param { std::vector<Tree*>& treeStrg }
%parse-param { std::map<std::string, Fact*>& factsStrg }
%parse-param { std::vector<std::string>& factsOutput }

%union {
    Node*          node_ptr;
    Tree*          tree;
    Operation*     oper_ptr;
    Fact*          fact_ptr;
    char*                   fact;
    char*                   oper;
}

%token <oper> IFOIF AND OR XOR IMPL NOT LPAREN RPAREN
%token ENDL T_INIT_FACTS T_QUERY_LIST
%token <fact> FACT

%type <tree> rule
%type <oper_ptr> expression
%type <fact_ptr> operand
%type <node_ptr> lexpr rexpr

%left IFOIF
%left IMPL
%left XOR
%left OR
%left AND
%left NOT
%left LPAREN RPAREN

%%
start:
    prog_skeleton
    | newlines prog_skeleton

prog_skeleton:
    rules_list init_facts quries_list

rules_list:
    rules_list rule { treeStrg.push_back($2); }
    | rule { treeStrg.push_back($1); }

init_facts:
    T_INIT_FACTS facts_initialization newlines {}
    | T_INIT_FACTS newlines

quries_list:
    T_QUERY_LIST output_facts newlines {} 
    | T_QUERY_LIST output_facts

rule:
    expression newlines { $$ = new Tree($1); }

expression:
    lexpr IMPL rexpr { $$ = new Implication($2, $1, $3); }
    | lexpr IFOIF rexpr { $$ = new class IFOIF($2, $1, $3); }

lexpr:
    LPAREN lexpr RPAREN { $$ = $2; } 
    | NOT lexpr  { $$ = new Negation($1, $2); }
    | lexpr AND lexpr { $$ = new Conjunction($2, $1, $3); }
    | lexpr OR lexpr { $$ = new Disjunction($2, $1, $3); }
    | lexpr XOR lexpr { $$ = new ExclDisjunction($2, $1, $3); }
    | operand { $$ = $1; }

rexpr:
    rexpr AND rexpr { $$ = new Conjunction($2, $1, $3); }
    | NOT rexpr { $$ = new Negation($1, $2); }
    | operand { $$ = $1; }

facts_initialization:
    FACT {
        for (size_t i = 0; i < std::strlen($1); i++) {
            std::string   fact(1, $1[i]);
            if ( factsStrg.find(fact) == factsStrg.end() )
                factsStrg.insert( std::pair<std::string, Fact*>(fact, new Fact( fact, factValues::True ) ) );
            else
                factsStrg.at( fact )->SetValue(factValues::True);
        }
    }

output_facts:
    FACT {
        for (size_t i = 0; i < std::strlen($1); i++) {
            if ( factsStrg.find($1) == factsStrg.end() ) {
                factsStrg.insert(std::pair<std::string, Fact*>(std::string(1, $1[i]), new Fact( std::string(1, $1[i] ) ) ) );
            }
            factsOutput.push_back( std::string(1, $1[i]) );
        }
    }

operand:
    FACT {
        $$ = new Fact( $1 );
        if ( factsStrg.find($1) == factsStrg.end() ) {
            factsStrg.insert( std::pair<std::string, Fact*>($1, $$) );
        }
        else {
            delete $$;
            $$ = factsStrg[$1];
        }
    }

newlines:
    newlines ENDL
    | ENDL

%%

void        yyerror(std::vector<Tree*>& treeStrg, std::map<std::string, Fact*>& factsStrg,
                    std::vector<std::string>& factsOutput, const char* s) {
    throw SyntaxException(s, linenum);
}
