%verbose
%{
    #include <cstring>
    #include <cstdio>
    #include  "Tree.hpp"
    #include <iostream>
    int yylex();
    extern "C" int yyparse();
    extern "C" FILE* yyin;
    extern int  linenum; // declaring linenum as extern int, this stands that somewhere this variable is already defined
    void        yyerror(std::vector<ast::Tree*>& treeStrg, std::map<std::string, bool>& factsStrg, std::vector<std::string>& factsOutput, char const* s);
%}


%code requires {
    #include "Tree.hpp"
}

%parse-param { std::vector<ast::Tree*>& treeStrg }
%parse-param { std::map<std::string, bool>& factsStrg }
%parse-param { std::vector<std::string>& factsOutput }

%union {
    ast::Tree*  tree;
    ast::Node*  node;
    char*       fact;
    char*       oper;
}

%token <oper> IFOIF AND OR XOR IMPL NOT LPAREN RPAREN
%token ENDL T_INIT_FACTS T_QUERY_LIST
%token <fact> FACT

%type <tree> expression1
%type <node> expression
%type <node> operand

%left IFOIF
%left IMPL
%left XOR
%left OR
%left AND
%left NOT
%left LPAREN RPAREN

%%
start:
    prog_skeleton
    | newlines prog_skeleton

prog_skeleton:
    rules_list init_facts quries_list

init_facts:
    init_facts T_INIT_FACTS facts_initialization { std::cout << "INIT GO ON!" << std::endl; }
    | T_INIT_FACTS facts_initialization newlines { } // we allowed to have '=[facts]' only one time in a file
    | T_INIT_FACTS facts_initialization

quries_list:
    quries_list T_QUERY_LIST output_facts { std::cout << "QUERY GO ON!" << std::endl; }
    |  T_QUERY_LIST output_facts newlines { } // we allowed to have '?[facts]' only one time in a file
    |   T_QUERY_LIST output_facts

rules_list:
    rules_list expression1 { treeStrg.push_back($2); } // do we need both?
    | expression1 { treeStrg.push_back($1); } // do we need both?

expression1:
    expression newlines { $$ = new ast::Tree($1, factsStrg); }; // try out: expression COMMENT newline

expression:
    LPAREN expression RPAREN { $$ = $2; } 
    | NOT expression  { $$ = new ast::Node("oper", $1); $$->addChild($2); }
    | expression AND expression { $$ = new ast::Node("oper", $2); $$->addChild($1); $$->addChild($3); std::cout << $$->GetValuePair().second << std::endl; }
    | expression OR expression { $$ = new ast::Node("oper", $2); $$->addChild($1); $$->addChild($3); std::cout << $$->GetValuePair().second << std::endl; }
    | expression XOR expression { $$ = new ast::Node("oper", $2); $$->addChild($1); $$->addChild($3); std::cout << $$->GetValuePair().second << std::endl; }
    | expression IMPL expression { $$ = new ast::Node("oper", $2); $$->addChild($1); $$->addChild($3); std::cout << $$->GetValuePair().second << std::endl; }
    | expression IFOIF expression { $$ = new ast::Node("oper", $2); $$->addChild($1); $$->addChild($3); std::cout << $$->GetValuePair().second << std::endl; }
    | operand { $$ = $1; }

facts_initialization:
    FACT {
        for (size_t i = 0; i < std::strlen($1); i++)
        {
            const std::string   fact(1, $1[i]);
            std::map<std::string, bool>:: iterator it = factsStrg.find( fact );
            if ( it == factsStrg.end() )
                factsStrg.insert( std::pair<std::string, bool>( fact, true ) );
            else
                it->second = true;
        }
    }

output_facts:
    FACT {
        for (size_t i = 0; i < std::strlen($1); i++)
            factsOutput.push_back( std::string(1, $1[i]) );
    }

operand:
    FACT {
        $$ = new ast::Node("fact", $1);
        if ( factsStrg.find($1) == factsStrg.end() )
            factsStrg.insert( std::pair<std::string, bool>($1, false) );
    }

newlines:
    newlines ENDL
    | ENDL

%%

void        yyerror(std::vector<ast::Tree*>& treeStrg, std::map<std::string, bool>& factsStrg, std::vector<std::string>& factsOutput, char const* s)
{
    std::cerr << s << ":" << std::endl << "\t-------->P.S.: Give a quick look at line #"
                 << ((!linenum) ? 1 : linenum) << std::endl;
    exit(-1);
}
